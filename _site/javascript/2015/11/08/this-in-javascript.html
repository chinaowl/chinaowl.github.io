<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="this has always been a confusing JavaScript keyword to me. Thanks to the You Don’t Know JavaScript series by Kyle Simpson, it’s become slightly less confusing.">

    <title>`this` in JavaScript</title>
    
    <link rel="stylesheet" href=" /assets/css/main.css ">
    <link rel="canonical" href="http://chinaowl.co/javascript/2015/11/08/this-in-javascript.html">
    <link rel="alternate" type="application/rss+xml" title="China Wang" href="http://chinaowl.co /feed.xml ">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Merriweather|Pacifico|Source+Code+Pro">
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
</head>

<body>
  <div class=wrapper>
    <header>
  <a href="/">
    <div class="header">
      China Wang
    </div>
  </a>
  <ul class="nav">
    <a href="/writing">
      <li class="nav__item">Writing</li>
    </a> |
    <a href="/projects">
      <li class="nav__item">Projects</li>
    </a>
  </ul>
</header>
    <div class="content">
      <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">`this` in JavaScript</h1>
    <p class="post-meta"><time datetime="2015-11-08T00:00:00-08:00" itemprop="datePublished">November 8, 2015</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p><code class="highlighter-rouge">this</code> has always been a confusing JavaScript keyword to me. Thanks to the <em><a href="https://github.com/getify/You-Dont-Know-JS">You Don’t Know JavaScript</a></em> series by Kyle Simpson, it’s become slightly less confusing.</p>

<p>This post will mostly be notes I took from the second chapter of the third book in the series, <em><code class="highlighter-rouge">this</code> &amp; Object Prototypes</em>.</p>

<p>(My only major gripe was that all the code examples used <code class="highlighter-rouge">foo</code>, <code class="highlighter-rouge">bar</code>, and <code class="highlighter-rouge">baz</code>. I feel that meaningless functions make it hard to understand how you would use <code class="highlighter-rouge">this</code> in real life code. Hence, I tried to come up with my own examples using more meaningful functions, but unsurprisingly, it was rather difficult.)</p>

<p>First, the author makes the point that <code class="highlighter-rouge">this</code> has nothing to do with scope:</p>

<blockquote>
  <p>To be clear, <code class="highlighter-rouge">this</code> does not, in any way, refer to a function’s lexical scope.</p>
</blockquote>

<p>So what <em>does</em> <code class="highlighter-rouge">this</code> have to do with?</p>

<blockquote>
  <p><code class="highlighter-rouge">this</code> is not an author-time binding but a runtime binding. It is contextual based on the conditions of the function’s invocation. <code class="highlighter-rouge">this</code> binding has nothing to do with where a function is declared, but has instead everything to do with the manner in which the function is called.</p>
</blockquote>

<p>You have to examine the call-site and the call-stack and consult the following four rules to figure out what <code class="highlighter-rouge">this</code> refers to.</p>

<h2 id="rule-one-default-binding">Rule One: Default Binding</h2>

<ul>
  <li>
    <p>most common case</p>
  </li>
  <li>
    <p>standalone function invocation</p>
  </li>
  <li>
    <p>default catch-all rule</p>
  </li>
  <li>
    <p>applies when a function is called with a plain, undecorated function reference</p>

    <p>var counter = 0;</p>

    <p>function incrementCounter() {
    this.counter++;
}</p>

    <p>incrementCounter();
console.log(counter); // 1 - got incremented`&lt;/pre&gt;</p>

    <p>Note: if the function is in <code class="highlighter-rouge">strict mode</code>, the global object is not eligible for the default binding, so <code class="highlighter-rouge">this.counter</code> in the above code would throw an error.</p>

    <h2 id="rule-two-implicit-binding">Rule Two: Implicit Binding</h2>
  </li>
  <li>
    <p>consider whether the call-site has a context object (i.e., owning/containing object)&lt;pre&gt;`var counter = 0;</p>

    <p>function incrementCounter() {
    this.counter++;
}</p>

    <p>var object = {
    counter: 10,
    incrementCounter: incrementCounter,
};</p>

    <p>object.incrementCounter();
console.log(counter); // 0 - did not get incremented
console.log(object.counter); // 11 - got incremented`&lt;/pre&gt;</p>

    <p>But wait! There’s more. In some situations, the implicit binding can be lost.</p>

    <pre>`var counter = 0;

function incrementCounter() {
    this.counter++;
}

var object = {
    counter: 10,
    incrementCounter: incrementCounter,
};

var copyOfIncrementCounter = object.incrementCounter;

copyOfIncrementCounter();
console.log(counter); // 1 - got incremented
console.log(object.counter); // 10 - did not get incremented
`</pre>

    <p>Here, <code class="highlighter-rouge">copyOfIncrementCounter</code> looks like it’s a reference to <code class="highlighter-rouge">object.incrementCounter</code>, but it’s actually a reference to the global <code class="highlighter-rouge">incrementCounter</code>. So we fall back to the default binding rule and the global <code class="highlighter-rouge">counter</code> variable gets incremented.</p>

    <p>Another example of this situation:</p>

    <pre>`var counter = 0;

function incrementCounter() {
    this.counter++;
}

var object = {
    counter: 10,
    incrementCounter: incrementCounter
};

function doSomething(callback) {
    callback();
}

doSomething(object.incrementCounter);
console.log(counter); // 1 - got incremented
console.log(object.counter); // 10 - did not get incremented
`</pre>

    <p>Why?</p>

    <blockquote>
      <p>Parameter passing is just an implicit assignment, and since we’re passing a function, it’s an implicit reference assignment, so the end result is the same as the previous snippet.</p>
    </blockquote>

    <h2 id="rule-three-explicit-binding">Rule Three: Explicit Binding</h2>
  </li>
  <li>force a function call to use a particular object as <code class="highlighter-rouge">this</code></li>
  <li>use <code class="highlighter-rouge">call</code> and <code class="highlighter-rouge">apply</code>, which are available to all functions</li>
  <li><code class="highlighter-rouge">call</code> and <code class="highlighter-rouge">apply</code> are methods that take an object to use for <code class="highlighter-rouge">this</code> as their first argument</li>
  <li>
    <p><code class="highlighter-rouge">call</code> and <code class="highlighter-rouge">apply</code> are identical with respect to <code class="highlighter-rouge">this</code>; we won’t worry about their differences for now&lt;pre&gt;`var counter = 0;</p>

    <p>function incrementCounter() {
    this.counter++;
}</p>

    <p>var object = {
    counter: 10
};</p>

    <p>incrementCounter.call(object);
console.log(counter); // 0 - did not get incremented
console.log(object.counter); // 11 - got incremented`&lt;/pre&gt;</p>

    <p>Note that if a primitive is passed instead of an object, it gets wrapped in its object-form (<code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">Boolean</code>, or <code class="highlighter-rouge">Number</code>). This is called <em>boxing</em>.</p>

    <blockquote>
      <p>Unfortunately, explicit binding alone still doesn’t offer any solution to the issue mentioned previously, of a function “losing” its intended <code class="highlighter-rouge">this</code> binding…</p>
    </blockquote>

    <p>…but <em>hard binding</em>, a variation pattern around explicit binding, will work.</p>

    <pre>`var counter = 0;

function incrementCounter() {
    this.counter++;
}

var object = {
    counter: 10
};

var incrementCounterWrapper = function() {
    incrementCounter.call(object);
}

incrementCounterWrapper();
console.log(counter); // 0 - did not get incremented
console.log(object.counter); // 11 - got incremented

incrementCounterWrapper.call(window); // will it use the global counter? nope!
console.log(counter); // 0 - did not get incremented
console.log(object.counter); // 12 - got incremented
`</pre>

    <p>What’s happening here is <code class="highlighter-rouge">incrementCounterWrapper</code> internally calls <code class="highlighter-rouge">incrementCounter</code> with <code class="highlighter-rouge">object</code> as <code class="highlighter-rouge">this</code>. No matter how <code class="highlighter-rouge">incrementCounterWrapper</code> is called, it will always manually invoke <code class="highlighter-rouge">incrementCounter</code> with <code class="highlighter-rouge">object</code>.</p>

    <blockquote>
      <p>Since hard binding is such a common pattern, it’s provided with a built-in utility as of ES5, <code class="highlighter-rouge">Function.prototype.bind</code></p>
    </blockquote>

    <blockquote>
      <p><code class="highlighter-rouge">bind(..)</code> returns a new function that is hardcoded to call the original function with the <code class="highlighter-rouge">this</code> context set as you specified.</p>
    </blockquote>

    <pre>`var counter = 0;

function incrementCounter() {
    this.counter++;
}

var object = {
    counter: 10
};

var incrementCounterWrapper = incrementCounter.bind(object);

incrementCounterWrapper();
console.log(counter); // 0 - did not get incremented
console.log(object.counter); // 11 - got incremented
`</pre>

    <h2 id="rule-four-new-binding">Rule Four: <code class="highlighter-rouge">new</code> Binding</h2>

    <p>Ah, the <code class="highlighter-rouge">new</code> keyword. Another confusing one that I often see but am never sure when to use myself.</p>

    <blockquote>
      <p>JavaScript has a <code class="highlighter-rouge">new</code> operator, and the code pattern to use it looks basically identical to what we see in those class-oriented languages; most developers assume that JavaScript’s mechanism is doing something similar. However, there really is no connection to class-oriented functionality implied by <code class="highlighter-rouge">new</code> usage in JS.</p>
    </blockquote>

    <p>Okay, what else?</p>

    <blockquote>
      <p>First, let’s re-define what a “constructor” in JavaScript is. In JS, constructors are just functions that happen to be called with the <code class="highlighter-rouge">new</code> operator in front of them. They are not attached to classes, nor are they instantiating a class. They are not even special types of functions. They’re just regular functions that are, in essence, hijacked by the use of new in their invocation.</p>
    </blockquote>

    <p>How is <code class="highlighter-rouge">new</code> relevant to <code class="highlighter-rouge">this</code>, then?</p>

    <p>Well, when a function is invoked with <code class="highlighter-rouge">new</code>, a brand new object is created. That object is set as the <code class="highlighter-rouge">this</code> binding for that function call. And that function call will return the new object (unless the function returns its own alternate object).</p>

    <pre>`var counter = 0;

function incrementCounter(counter) {
    this.counter = counter;
    this.counter++;
}

var newIncrementCounter = new incrementCounter(10);

console.log(counter); // 0 - did not get incremented
console.log(newIncrementCounter.counter); // 11 - got incremented

</pre>
  </li>
</ul>
<p>## Rule Precedence</p>

<ol>
  <li><code class="highlighter-rouge">new</code> binding</li>
  <li>explicit binding</li>
  <li>implicit binding</li>
  <li>default binding</li>
</ol>

<p>More detailed:</p>

<blockquote>
  <ol>
    <li>Is the function called with <code class="highlighter-rouge">new</code> (new binding)? If so, <code class="highlighter-rouge">this</code> is the newly constructed object.
<code class="highlighter-rouge">var bar = new foo()</code></li>
    <li>Is the function called with <code class="highlighter-rouge">call</code> or <code class="highlighter-rouge">apply</code> (explicit binding), even hidden inside a <code class="highlighter-rouge">bind</code> hard binding? If so, <code class="highlighter-rouge">this</code> is the explicitly specified object.
<code class="highlighter-rouge">var bar = foo.call( obj2 )</code></li>
    <li>Is the function called with a context (implicit binding), otherwise known as an owning or containing object? If so, <code class="highlighter-rouge">this</code> is that context object.
<code class="highlighter-rouge">var bar = obj1.foo()</code></li>
    <li>Otherwise, default the <code class="highlighter-rouge">this</code> (default binding). If in <code class="highlighter-rouge">strict mode</code>, pick <code class="highlighter-rouge">undefined</code>, otherwise pick the global object.
<code class="highlighter-rouge">var bar = foo()</code></li>
  </ol>
</blockquote>

<p>For a discussion on why this is the case, read the original material <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%2526%20object%20prototypes/ch2.md#everything-in-order">here</a>.</p>

<p>(And just read the whole thing while you’re at it.)</p>

  </div>

</article>

    </div>
    <footer class="footer">
  <pre>{O.O}
(|||)
^  ^</pre>
</footer>
  </div>
</body>

</html>